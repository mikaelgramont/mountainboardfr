<?php
/**
 * Generates JS validation rules for form fields
 *
 * @author Jani Hartikainen <firstname at codeutopia net>
 */
class Lib_Form_Decorator_JsValidation extends Zend_Form_Decorator_Abstract
{
	/**
	 * The name of the form
	 * @var string
	 */
	protected $_formName;

	protected $_validatorList = array(
	    0 => 'Zend_Validate_Alnum',
	    1 => 'Zend_Validate_Alpha',
	    2 => 'Zend_Validate_Between',
	    3 => 'Zend_Validate_Date',
	    4 => 'Zend_Validate_Digits',
	    5 => 'Zend_Validate_EmailAddress',
	    6 => 'Zend_Validate_Float',
	    7 => 'Zend_Validate_GreaterThan',
	    8 => 'Zend_Validate_Hostname',
	    9 => 'Zend_Validate_Identical',
	   10 => 'Zend_Validate_InArray',
	   11 => 'Zend_Validate_Int',
	   12 => 'Zend_Validate_LessThan',
	   13 => 'Zend_Validate_NotEmpty',
	   14 => 'Zend_Validate_Regex',
	   15 => 'Zend_Validate_StringLength',
	   16 => 'Lib_Validate_IdenticalTo',
	   17 => 'Lib_Form_Element_Username_Validate',
	   18 => 'Lib_Form_Element_Email_Validate_Exists',
	   19 => 'Lib_Validate_DateTime',
	   20 => 'Lib_Validate_LocationRequired',
	);

	protected $_containerClasses = array(
	   'Zend_Form_DisplayGroup',
	);

	public function render($content)
	{
		$form = $this->getElement();
		$view = $form->getView();
		$this->_formName = $form->getName();

		if(!$this->_formName)
			$this->_formName = 'form';

		$js = "
Lib.Form.Forms = Lib.Form.Forms || { };\r\n".
"Lib.Form.Forms." . $this->_formName . " = { };\r\n";

        $js .= $this->_getContainerScript($form);

		$view->getHelper('jQuery')->addOnLoad($js);
        /*$view->inlineScript()->captureStart();

		echo $js;
		$view->inlineScript()->captureEnd();*/

		return $content;
	}

	/**
	 * Get the script generated by all the elements
	 * contained in the given container
	 *
	 * @param mixes $container
	 * @return string
	 */
	protected function _getContainerScript($container)
	{
        $script = "";
	    foreach($container as $element){
	        $class = get_class($element);

	        if(in_array($class, $this->_containerClasses)){
                $script .= $this->_getContainerScript($element);
	        } else {
                $script .= $this->_getElementScript($element);
	        }
        }
        return $script;
	}

	/**
	 * Get the script generated for the validation of a given element
	 *
	 * @param Zend_Form_Element $element
	 * @return string
	 */
	protected function _getElementScript($element)
	{
        $script = "";
	    $validators = $element->getValidators();

		if(count($validators) > 0){
            $script = $this->_buildValidationRules($element);
        }

        return $script;
	}

	/**
	 * Generate the JavaScript code for the validation rules
	 * @param Zend_Form_Element $element
	 * @return string
	 */
	protected function _buildValidationRules(Zend_Form_Element $element)
	{
		$name = $element->getName();
		$formName = $this->_formName;
		$validators = $element->getValidators();

		$arrValidatorId = array_flip($this->_validatorList);

		$rules = array();
		foreach($validators as $validator)
		{
			$class = get_class($validator);
			$data = $this->_buildValidatorData($class, $validator);
			$params = $data['params'];
			$messages = $data['messages'];

			if(!isset($arrValidatorId[$class])){
			    continue;
			}

			if(isset($validator->zfBreakChainOnFailure) && $validator->zfBreakChainOnFailure){
			    $breakChainOnFailure = 'true';
			} else {
			    $breakChainOnFailure = 'false';
			}
			$id = 'id'.$arrValidatorId[$class];
			$rules[] = "{name: '$id', breakChainOnFailure: $breakChainOnFailure, parameters: $params, messages: $messages}";
		}

		if(count($rules) > 0){
			$script = "Lib.Form.Forms." . $this->_formName . ".$name = [ " . implode(', ', $rules) . " ];".PHP_EOL;
		} else {
		    $script = '';
		}
		return $script;
	}

	/**
	 * Generate parameters for a validator rule
	 * @param string $class The name of the validator class
	 * @param Zend_Validate_Interface $validator the validator
	 * @return string
	 */
	protected function _buildValidatorData($class, Zend_Validate_Interface $validator)
	{

        $data = array();
        $data['messages'] = $this->_getErrorMessages($validator);

	    $params = '{';

        switch($class)
		{
            case 'Zend_Validate_Alnum':
			case 'Zend_Validate_Alpha':
				$params .= '{allowWhiteSpace: '.(($validator->allowWhiteSpace) ? 'true' : 'false');
				break;

			case 'Zend_Validate_Between':
				$params .= 'min:'.$validator->getMin().', max:'.$validator->getMax().', inclusive:'.$validator->getInclusive();
				break;

            case 'Zend_Validate_Date':
                switch(Zend_Registry::get('Zend_Locale')){
                    case 'fr':
                        $params .= 'regex: /^\d{1,2}(\-|\/|\.)\d{1,2}\1\d{4}$/';
                        break;
                    default:
                        $params .= 'regex: /^\d{1,2}(\-|\/|\.)\d{1,2}\1\d{4}$/';
                        break;
                }
				break;

            case 'Zend_Validate_GreaterThan':
                $params .= 'min:'.$validator->getMin();
                break;

            case 'Zend_Validate_Identical':
                $params .= "reference:'".$validator->getToken()."'";
                break;

            case 'Zend_Validate_InArray':
                $array = $validator->getHaystack();
                $params .= 'haystack: ["' . implode($array, '", "') . '"]';
                break;

            case 'Zend_Validate_LessThan':
                $params .= 'max:'.$validator->getMax();
                break;

            case 'Zend_Validate_Regex':
                $params .= 'regex:'.$validator->getPattern();
                break;

            case 'Zend_Validate_StringLength':
                $min = $validator->getMin();
                $max = $validator->getMax();

                if($min !== null){
                    $params .= "min: $min";
                    if($max !== null){
                        $params .= ', ';
                    }
                }

                if($max !== null){
                    $params .= "max: $max";
                }
                break;

            case 'Lib_Validate_IdenticalTo':
                $params .= 'reference:"'.$validator->getReference().'"';
                break;

            case 'Lib_Validate_DateTime':
                switch(Zend_Registry::get('Zend_Locale')){
                    case 'fr':
                        $params .= 'regex: /^\d{4}(\-|\/|\.)\d{2}(\-|\/|\.)\d{2} \d{2}:\d{2}:\d{2}$/';
                        break;
                    default:
                        $params .= 'regex: /^\d{4}(\-|\/|\.)\d{2}(\-|\/|\.)\d{2} \d{2}:\d{2}:\d{2}$/';
                        break;
                }
				break;

			case 'Zend_Validate_Digits':
            case 'Zend_Validate_EmailAddress':
            case 'Zend_Validate_Float':
            case 'Zend_Validate_Hostname':
            case 'Zend_Validate_Int':
            case 'Zend_Validate_Ip':
            case 'Zend_Validate_NotEmpty':
            case 'Lib_Form_Element_Username_Validate':
            case 'Lib_Validate_LocationRequired':
            default:
                // No parameters needed
                break;
		}

        $params .= '}';
		$data['params']	= $params;
		return $data;
	}

    protected function _getErrorMessages($validator)
    {
	    $messages = $validator->getErrorTemplates();
        $translated = array();
		foreach($messages as $key => $message){
            $translated[] = addslashes(str_replace('-','',$key)).":". '"'.$validator->getTranslator()->_($key).'"';
        }

        $jsMessages = '{' . implode($translated, ", ") . '}';
        return $jsMessages;
    }
}
